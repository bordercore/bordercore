{% extends "base.html" %}

{% block title %} SQL Playground {% endblock %}

{% block content %}

    <div id="vue-app" class="p-3">
        <div class="d-flex flex-wrap">
            <div v-for="(tableInfo, tableName, index) in tables" class="mw-50">
                <card :title="`Table: ${tableName}`">
                    <template #content>
                        <o-table
                            :data="tables[tableName]['data']"
                            hoverable
                            sort-icon="angle-up"
                        >
                            <o-table-column :field="col" :label="col" v-slot="props" v-for="col in tableInfo.cols" sortable>
                                [[ props.row[col] ]]
                            </o-table-column>
                        </o-table>
                    </template>
                </card>
            </div>
            <div v-if="Object.keys(tables).length === 0" class="w-100">
                <card title="">
                    <template #content>
                        <div>
                            No tables found
                        </div>
                    </template>
                </card>
            </div>
        </div>
        <card title="" class="hover-target">
            <template #title-slot>
                <div class="d-flex">
                    <div class="card-title">
                        SQL
                    </div>
                    <div class="dropdown-menu-container ms-auto">
                        <drop-down-menu :show-on-hover="true">
                            <template #dropdown>
                                <li>
                                    <a class="dropdown-item" href="#" @click.prevent="handleImportDB">
                                        <font-awesome-icon icon="file-import" class="text-primary me-3"></font-awesome-icon>Import DB
                                    </a>
                                </li>
                            </template>
                        </drop-down-menu>
                    </div>
                </div>
            </template>
            <template #content>
                <textarea v-model="sql" class="sql-input mt-2 p-3 w-100" rows="3" placeholder="Your SQL Here..." @keydown="handleKeyDown"></textarea>
                <input class="btn btn-primary" type="button" value="Run" @click="handleRunSQL" />
                <a href="#" id="exportButton" class="btn btn-primary" type="button">Export</a>
                <input type="file" id="importDB" class="d-none">
            </template>
        </card>
        <card title="Error" v-if="error">
            <template #content>
                <div class="text-danger">
                    [[ error ]]
                </div>
            </template>
        </card>
        <card title="Output" v-if="showOutput">
            <template #content>
                <o-table
                    :data="output['data']"
                    hoverable
                    sort-icon="angle-up"
                >
                    <o-table-column :field="col" :label="col" v-slot="props" v-for="col in output['cols']" sortable>
                        [[ props.row[col] ]]
                    </o-table-column>
                    <template #empty>
                        No data found
                    </template>
                </o-table>
            </template>
        </card>
    </div>

{% endblock %}

{% block javascript %}

    {{ block.super }}

    <script type="text/javascript" charset="utf-8">

        const log = (...args) => console.log(...args);
        const logError = (...args) => console.error(...args);

        const app = createApp({
            name: "SQLPlayground",
            delimiters: ["[[", "]]"],
            components: {
                Card,
                DropDownMenu,
                FontAwesomeIcon,
            },
            setup() {
                const error = ref("");
                const showOutput = ref(false);
                const sql = ref(null);
                let sqlite3 = null;
                const tables = ref({});
                const output = ref([]);
                let db = null;

                sqlite3InitModule({
                    print: log,
                    printErr: logError,
                }).then((_sqlite3) => {
                    try {
                        sqlite3 = _sqlite3;
                        db = new sqlite3.oo1.DB("/mydb.sqlite3", "c");
                        const byteArray = sqlite3.capi.sqlite3_js_db_export(db);
                        const blob = new Blob([byteArray.buffer], {type: "application/x-sqlite3"});
                        const exportButton = document.getElementById("exportButton");
                        exportButton.href = window.URL.createObjectURL(blob);
                        exportButton.download = ("/mydb.sqlite3");
                    } catch (err) {
                        logError(err.name, err.message);
                    }
                });

                function getTableData() {
                    for (const table in tables.value) {
                        tables.value[table]["data"] = [];
                            db.exec({
                                sql: `SELECT * FROM ${table} ORDER BY ${tables.value[table]["cols"].join(",")}`,
                                callback: (row, stmt) => {
                                    const newRow = {};
                                    const columns = stmt.getColumnNames();
                                    for (let i = 0; i < columns.length; i++) {
                                        newRow[columns[i]] = row[i];
                                    }
                                    tables.value[table]["data"].push(newRow);
                                },
                            });
                    }
                };

                function handleImportDB() {
                    document.getElementById("importDB").click();
                };

                function handleKeyDown(event) {
                    if (event.key === "Enter" && event.ctrlKey) {
                        handleRunSQL();
                    }
                };

                function handleRunSQL() {
                    error.value = "";
                    output.value = {
                        data: [],
                    };
                    try {
                        db.exec({
                            sql: sql.value,
                            callback: (row, stmt) => {
                                showOutput.value = true;
                                const newRow = {};
                                const columns = stmt.getColumnNames();
                                for (let i = 0; i < columns.length; i++) {
                                    newRow[columns[i]] = row[i];
                                }
                                output.value["cols"] = columns;
                                output.value["data"].push(newRow);
                            },
                        });
                    } catch (err) {
                        error.value = err;
                        console.log(`Error: ${err}`);
                    }
                };

                function populateDatabase() {
                    tables.value = {};
                    db.exec({
                        sql: "SELECT name FROM sqlite_master WHERE type='table'",
                        callback: (rowTable) => {
                            if (!rowTable[0].endsWith("_sequence")) {
                                tables.value[rowTable] = {"cols": []};
                                db.exec({
                                    sql: `PRAGMA table_info(${rowTable})`,
                                    callback: (rowCol) => {
                                        tables.value[rowTable]["cols"].push(rowCol[1]);
                                    },
                                });
                            }
                        },
                    });
                };

                onMounted(() => {
                    document.getElementById("importDB").addEventListener("change", function() {
                        const file = this.files[0];
                        const r = new FileReader();
                        r.addEventListener("load", function() {
                            const arrayBuffer = this.result;
                            const p = sqlite3.wasm.allocFromTypedArray(arrayBuffer);
                            const rc = sqlite3.capi.sqlite3_deserialize(
                                db.pointer, "main", p, arrayBuffer.byteLength, arrayBuffer.byteLength,
                                sqlite3.capi.SQLITE_DESERIALIZE_RESIZEABLE,
                            );
                            db.checkRc(rc);
                            populateDatabase();
                            getTableData();
                            // Reset the file input so that the "change" event
                            //  will fire again if we import another db
                            document.getElementById("importDB").value = "";
                        });
                        r.readAsArrayBuffer(file);
                    });
                });

                return {
                    error,
                    handleImportDB,
                    handleKeyDown,
                    handleRunSQL,
                    output,
                    showOutput,
                    sql,
                    tables,
                };
            },
        });
        app.use(Oruga, {
            iconPack: "fas",
        });
        app.mount("#vue-app");

    </script>

{% endblock %}
