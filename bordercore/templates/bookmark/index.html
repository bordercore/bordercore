{% extends "base.html" %}

{% load dict_get %}
{% load jsonify %}

{% load favicon %}

{% block title %} Bookmarks {% endblock %}

{% block left-block %}
{% endblock %}

{% block content %}

    <div id="vue-app-top">

        {% include "common/show_messages.html" %}

        <div class="row">

            <div class="col-lg-12 bookmark-search">

                <form class="form-inline" role="form" id="search-form" method="get" @submit.prevent>
                    {% csrf_token %}
                    <input type="hidden" id="add-to-remote-from-favorite-tagname" name="tag" />

                    <div class="form-group col-auto has-search">
                        <span class="fas fa-search form-control-feedback"></span>
                        <search inline-template @search-term="searchTerm" @search-tag="searchTag" @get-page="getPage" ref="search">
                            <div>
                                <vue-simple-suggest ref="suggestComponent"
                                                    v-model="query"
                                                    display-attribute="value"
                                                    value-attribute="value"
                                                    :list="tagSearch"
                                                    :filter-by-query=true
                                                    :debounce=200
                                                    :name="inputName"
                                                    placeholder="Search"
                                                    autofocus
                                                    autocomplete="off"
                                                    id="searchInput"
                                                    @select="onSelect"
                                                    @keydown.native.enter="onEnter"
                                                    :styles="autoCompleteStyle"
                                                    @hide-list="onHideList"
                                                    @hover="onHover"
                                >
                                </vue-simple-suggest>
                            </div>
                        </search>
                    </div>

                    <button-group inline-template @get-page="getPage">
                        <div class="btn-group">
                            <a class="btn btn-secondary" id="btn-add" href="{% url 'bookmark_add' %}">Add</a>
                            <input type="button" class="btn btn-secondary" id="btn-edit" value="Edit" :disabled="buttonsDisabled" @click="onClickEdit" />
                            <input type="button" class="btn btn-secondary" id="btn-delete" value="Delete" :disabled="buttonsDisabled" @click="onClickDelete" />
                            <input v-if="removeFavoriteButtonVisible" type="button" class="btn btn-secondary ml-2" value="Remove from Favorites" @click="removeFromFavorites" v-cloak />
                            <input v-if="addFavoriteButtonVisible" type="button" class="btn btn-secondary ml-2" value="Add to Favorites" @click="addToFavorites" v-cloak />
                        </div>
                    </button-group>

                </form>

            </div>

        </div>

    </div>

    <div class="row ml-3 mt-3">

        <div class="col-lg-3">

            <div id="vue-app-left">

                <add-note inline-template>
                    <div id="bookmark-sidebar" >
                        <form>
                            <div class="form-group">
                                <label class="col-form-label">Note</label>
                                <textarea class="form-control" id="note" rows="9" v-model="note"></textarea>
                            </div>
                            <button id="btn-add-note" type="button" class="btn btn-primary" @click="onClick">Add</button>
                        </form>
                    </div>
                </add-note>

                <ul class="list-group" id="sort-container-tags">
                    <tag-list inline-template>
                        <div>
                            <draggable v-model="favoriteTags" @change="onChange" ghost-class="sortable-ghost" draggable=".draggable">
                                <transition-group type="transition">
                                    <li v-for="tag in favoriteTags" class="list-group-item" :class="{ active: tag.isActive, draggable: tag.isDraggable, 'bookmark-tag-list-header': tag.isHeader }" :data-id="tag.id" :key="tag.id" v-cloak>
                                        <template v-if="tag.isHeader">
                                            [[ tag.name ]]
                                        </template>
                                        <template v-else>
                                            <a href="" @click.prevent="onClick" :data-tag="tag.name">[[ tag.name ]]</a>
                                        </template>
                                        <span v-if="tag.count" class="ml-2 badge" :class="{ 'badge-light': tag.isActive, 'badge-primary': !tag.isActive }">[[ tag.count ]]</span>
                                    </li>
                                </transition-group>
                            </draggable>
                        </div>
                    </tag-list>
                </ul>

                <randomize-button inline-template>
                    <form role="form" action="" method="get">
                        <div class="btn-group mt-5">
                            <button class="btn btn-secondary" @click.prevent="onClick" id="btn-random">Randomize</button>
                        </div>

                        <div class="btn-group mt-5">
                            <a class="btn btn-secondary" href="{% url 'bookmark_import' %}">Import</a>
                        </div>
                    </form>
                </randomize-button>

            </div>

        </div>

        <div class="col-lg-9">

            <div id="vue-app-right">

                <bookmark-list inline-template @paginate="paginate" ref="bookmarkList">
                    <div class="row">
                        <div class="col-lg-12">
                            <table>
                                <tbody is="draggable" v-model="bookmarkList" @change="onChange" ghost-class="sortable-ghost" :disabled="disableSort">
                                    <transition-group type="transition">
                                        <tr v-for="bookmark in bookmarkList" :data-id="bookmark.id" :key="bookmark.id" class="bookmark-list" @click="onClick" v-cloak>
                                            <td class="bookmark-list-date p-2">
                                                <span>[[ bookmark.created ]]</span>
                                            </td>
                                            <td class="bookmark-list-favicon p-2">
                                                <span v-html="bookmark.favicon_url"></span>
                                            </td>
                                            <td class="bookmark-list-link p-2">
                                                <a class="one-tag" :href="bookmark.url" :id="bookmark.linkId" target="_blank">[[ unescapeHtml(bookmark.title) ]]</a>
                                                <a v-if="bookmark.lastResponseCode != 200" class="form-error ml-3" target="wayback" :href="'https://web.archive.org/web/1000/' + bookmark.url">[[ bookmark.lastResponseCode ]]</a>
                                                <i v-if="bookmark.note != null && bookmark.note != ''" class="fa fa-clipboard"></i>
                                                <a v-for="tag in bookmark.tags" v-if="tag != selectedTagName" class="badge badge-info ml-2" @click.prevent="onClick" href="">[[ tag ]]</a>
                                            </td>
                                        </tr>
                                    </transition-group>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </bookmark-list>

                <pagination inline-template :pagination="pagination" @get-page="getPage">
                    <div class="row" v-if="pagination.num_pages > 1">
                        <nav aria-label="Page navigation">
                            <ul class="pagination">
                                <li v-if="pagination.previous_page_number" class="page-item"><a class="page-link" @click.prevent="$emit('get-page', pagination.previous_page_number)" href="">Previous</a></li>
                                <li v-else class="disabled page-item"><a class="page-link" href="">Previous</a></li>

                                <template v-if="pagination.page_number - pagination.paginate_by > 1">
                                    <li class="page-item"><a class="page-link" @click.prevent="$emit('get-page', 1)" href="">1</a></li>
                                    <li v-if="pagination.page_number != pagination.paginate_by + 2" class="disabled page-item"><a class="page-link" href="">...</a></li>
                                </template>

                                <template v-for="page in pagination.range">

                                    <template v-if="pagination.page_number == page">
                                        <li class="disabled page-item">
                                            <a class="page-link" href="">[[ page ]]</a>
                                        </li>
                                    </template>
                                    <template v-else>
                                        <li class="page-item">
                                            <a class="page-link" @click.prevent="$emit('get-page', page)" href="">[[ page ]]</a>
                                        </li>
                                    </template>

                                </template>

                                <template v-if="pagination.num_pages - pagination.page_number > pagination.paginate_by">
                                    <li v-if="pagination.num_pages - pagination.page_number != pagination.paginate_by + 1"  class="disabled page-item"><a class="page-link" href="">...</a></li>
                                    <li class="page-item"><a class="page-link" @click.prevent="$emit('get-page', pagination.num_pages)" href="">[[ pagination.num_pages ]]</a></li>
                                </template>

                                <li v-if="pagination.next_page_number" class="page-item"><a class="page-link" @click.prevent="$emit('get-page', pagination.next_page_number)" href="">Next</a></li>
                                <li v-else class="disabled page-item"><a class="page-link" href="">Next</a></li>
                            </ul>
                        </nav>
                    </div>
                </pagination>

            </div>

        </div>

{% endblock %}

{% block javascript %}

    {{ block.super }}

    <script type="text/javascript">

        var isFiltered = false;

        // When this is set to true, then hitting "Enter" will NOT
        //  execute a general term search, but instead fire the event
        //  that initiates a tag search.
        disableTermSearch = false;

        Vue.mixin({ delimiters: ["[[", "]]"] });

        const EventBus = new Vue();

        const mapGetters = Vuex.mapGetters

        const store = new Vuex.Store({
            state: {
                addFavoriteButtonVisible: false,
                buttonsDisabled: true,
                selectedTagName: null,
                removeFavoriteButtonVisible: false
            },
            getters: {
                addFavoriteButtonVisible: state => {
                    return state.addFavoriteButtonVisible
                },
                buttonsDisabled: state => {
                    return state.buttonsDisabled
                },
                removeFavoriteButtonVisible: state => {
                    return state.removeFavoriteButtonVisible
                },
                selectedTagName: state => {
                    return state.selectedTagName
                },
            },
            mutations: {
                addFavoriteButtonVisible (state, payload) {
                    state.addFavoriteButtonVisible = payload
                },
                changeButtonsDisabled (state, payload) {
                    state.buttonsDisabled = payload
                },
                removeFavoriteButtonVisible (state, payload) {
                    state.removeFavoriteButtonVisible = payload
                },
                selectedTagName (state, payload) {
                    state.selectedTagName = payload
                }
            },
        });

        const ButtonGroup = {
            computed: mapGetters(["addFavoriteButtonVisible", "buttonsDisabled", "removeFavoriteButtonVisible"]),
            methods: {
                onClickDelete(evt) {

                    var bookmarkEl = document.querySelector("tr.bookmark-list.selected");
                    var selectedId = bookmarkEl.dataset.id;

                    var self = this;

                    axios.delete("{% url 'bookmark_delete' 666 %}".replace(/666$/, selectedId))
                         .then(() => {

                             this.$store.commit("changeButtonsDisabled", true)

                             if (this.$store.getters.selectedTagName) {
                                 document.getElementById("bookmark-sidebar").classList.remove("show");
                             }

                             self.$emit("get-page", 1);

                         })
                },
                onClickEdit(evt) {
                    var selectedId = document.querySelector("tr.bookmark-list.selected").dataset.id;
                    window.location="{% url 'bookmark_edit' 666 %}".replace(/666$/, selectedId);
                },
                addToFavorites(evt) {
                    const tagName = this.$parent.$refs.search.$refs.suggestComponent.text
                    document.getElementById("add-to-remote-from-favorite-tagname").value = tagName;
                    const form = document.querySelector("#search-form");
                    form.method = "post";
                    form.action = "{% url 'add_favorite_tag' %}";
                    form.submit();
                },
                removeFromFavorites(evt) {
                    document.getElementById("add-to-remote-from-favorite-tagname").value = this.$store.getters.selectedTagName;
                    const form = document.querySelector("#search-form");
                    form.method = "post";
                    form.action = "{% url 'remove_favorite_tag' %}";
                    form.submit();
                }

            },
            mounted() {

                EventBus.$on("selected-favorite-tag", value => {
                    this.showRemoveFavorite = value;
                });

            }
        };

        const Search = {
            data() {
                return {
                    inputName: "search",
                    query: "",
                    tags: [],
                    autoCompleteStyle: {
                        vueSimpleSuggest: "position-relative",
                        inputWrapper: "search-box",
                        defaultInput: "form-control",
                        suggestions: "position-absolute list-group z-1000",
                        suggestItem: "list-group-item"
                    }
                }
            },
            methods: {
                tagSearch(query) {
                    return axios.get("{% url 'get_tags_used_by_bookmarks' %}?query=" + query)
                                .then(response => {
                                    return response.data;
                                })
                },
                onSelect(tag) {
                    this.$emit("search-tag", tag.value);
                    EventBus.$emit("select-favorite-tag", tag.value);
                    disableTermSearch = false;
                },
                onHideList() {
                    disableTermSearch = false;
                },
                onHover() {
                    disableTermSearch = true;
                },
                onEnter(evt) {

                    if (disableTermSearch) {
                        return;
                    }

                    searchTerm = evt.srcElement.value;

                    if (searchTerm) {
                        this.$store.commit("selectedTagName", searchTerm);
                        this.$emit("search-term", searchTerm);
                        EventBus.$emit("select-favorite-tag", null);
                        this.$store.commit("addFavoriteButtonVisible", false)
                        this.$store.commit("removeFavoriteButtonVisible", false)
                    } else {
                        // If the search box is empty, refresh the list with no filters
                        isFiltered = false;
                        this.$emit("get-page", 1);
                        EventBus.$emit("select-favorite-tag", "Untagged");
                        this.$store.commit("addFavoriteButtonVisible", false)
                        this.$store.commit("removeFavoriteButtonVisible", false)
                        this.$store.commit("selectedTagName", "");
                    }

                }
            }
        };

        new Vue({
            el: "#vue-app-top",
            store,
            components: {
                ButtonGroup,
                Search
            },
            methods: {
                getPage(pageNumber) {
                    EventBus.$emit("get-page", pageNumber);
                },
                searchTerm(searchTerm) {
                    EventBus.$emit("search-term", searchTerm);
                },
                searchTag(searchTag) {
                    EventBus.$emit("search-tag", searchTag);
                }
            }
        });

        const BookmarkList = {
            computed: mapGetters(["selectedTagName"]),
            data() {
                return {
                    bookmarkList: [],
                    disableSort: true,
                }
            },
            methods: {
                onClick(evt) {

                    element = evt.currentTarget;

                    if (evt.srcElement.classList.contains("badge")) {
                        const tagName = evt.srcElement.innerHTML;
                        EventBus.$emit("search-tag", tagName);
                        EventBus.$emit("select-favorite-tag", tag.value);
                    } else if (element.classList.contains("selected")) {

                        if (this.$store.getters.selectedTagName) {
                            document.getElementById("bookmark-sidebar").classList.remove("show");
                        }

                        element.classList.remove("selected");

                        this.$store.commit("changeButtonsDisabled", true)

                    } else {

                        if (this.$store.getters.selectedTagName) {
                            noteValue = "";

                            var selectedId = parseInt(element.dataset.id, 10);

                            const found = this.bookmarkList.find(element => element.id == selectedId);

                            if (found) {
                                noteValue = atob(found.note);
                            }

                            EventBus.$emit("setNoteValue", noteValue);

                            document.getElementById("bookmark-sidebar").classList.add("show");
                        }

                        const currentlySelected = document.querySelector("tr.bookmark-list.selected");
                        if (currentlySelected) {
                            currentlySelected.classList.remove("selected");
                        }
                        element.classList.add("selected");

                        this.$store.commit("changeButtonsDisabled", false)

                    }

                },
                onChange(evt) {

                    linkId = evt.moved.element.id;

                    // The backend expects the ordering to begin
                    // with 1, not 0, so add 1.
                    newPosition = evt.moved.newIndex + 1;

                    const bodyFormData = new URLSearchParams();
                    bodyFormData.append("tag", this.$store.getters.selectedTagName);
                    bodyFormData.append("link_id", linkId);
                    bodyFormData.append("position", newPosition);

                    axios("{% url "sort_bookmarks" %}", {
                        method: "POST",
                        data: bodyFormData,
                    }).then(response => {
                        if (response.data != "OK") {
                            this.$bvToast.toast("Sort error", {
                                title: 'Error',
                                autoHideDelay: 5000,
                            })
                            console.log("Sort error");
                        } else {
                            console.log("Success");
                        }
                    })
                      .catch((error) => {
                          this.$bvToast.toast(error, {
                              title: "Error",
                              noAutoHide: true,
                              variant: "danger"
                          })
                          console.error("Error:", error);
                      });
                },
                unescapeHtml(html) {
                    // Source: https://stackoverflow.com/a/46851765/378256
                    var el = document.createElement('div');
                    return html.replace(/\&[#0-9a-z]+;/gi, function (enc) {
                        el.innerHTML = enc;
                        return el.innerText
                    });
                },
                getBookmarkList({ pageNumber=null, searchTerm=null, searchTag=null, randomize=false } = {}) {
                    var self = this;

                    this.disableSort = true;
                    if (searchTerm != null) {
                        url = "{% url 'get_bookmarks_by_keyword' 666 %}".replace(/666$/, searchTerm);
                        isFiltered = true;
                    } else if (searchTag != null) {
                        url = "{% url 'get_bookmarks_by_tag' 666 %}".replace(/666$/, searchTag);
                        isFiltered = true;
                        this.disableSort = false;
                    } else if (randomize == true) {
                        isFiltered = true;
                        url = "{% url 'get_bookmarks_by_random' %}";
                    } else {

                        // If we've executed a search, ignore the automatic timed bookmarks refresh
                        if (isFiltered) {
                            return;
                        }

                        // A null pageNumber is passed in from the setInterval timer, so in that
                        // case use the current page number. We can't pass in the current page
                        // number directly from setInterval, since that gets set at page load
                        // time and can later change if the page number changes.
                        if (pageNumber == null) {
                            pageNumber = this.$parent.pageNumber;
                        }
                        url = "{% url 'get_bookmarks_by_page' 666 %}".replace(/666$/, pageNumber);
                    }

                    axios.get(url)
                         .then(function (response) {

                             var bookmarks = []
                             var lastDate = null;
                             for (bookmark of response.data.bookmarks) {
                                 if (bookmark.created == lastDate) {
                                     lastDate = bookmark.created;
                                     bookmark.created = null;
                                 } else {
                                     lastDate = bookmark.created;
                                 }
                                 bookmarks.push(bookmark);
                             }
                             if (searchTag != null) {
                                 // Only update the tagFilter here, *after* we have a new set of
                                 // updated bookmarks that's appropriate for this tagFilter
                                 self.$store.commit("selectedTagName", searchTag);
                             }

                             self.bookmarkList = bookmarks;

                             self.$emit("paginate", response.data.pagination);

                         })
                         .catch(function (error) {
                             console.log("Error getting new bookmarks list: " + error);
                         })
                         .finally(function () {
                         });
                },
            },
            mounted() {

                EventBus.$on("foobar", payload => {

                    this.bookmarkList.forEach( bookmark => {
                        if( bookmark.id == payload.id ) {
                            bookmark.note = btoa(payload.noteValue);
                        }
                    });

                });

                this.getBookmarkList({pageNumber: 1});

                window.setInterval(this.getBookmarkList, 60000, {pageNumber: null});

            }
        };

        const Pagination = {
            props: {
                pagination: ""
            }
        }

        new Vue({
            el: "#vue-app-right",
            store,
            components: {
                BookmarkList,
                Pagination,
            },
            data() {
                return {
                    pagination: "",
                    pageNumber: 1
                }
            },
            methods: {
                paginate(payload) {
                    this.pagination = payload;
                },
                getPage(pageNumber) {
                    this.pageNumber = pageNumber;
                    this.$refs.bookmarkList.getBookmarkList({pageNumber: pageNumber});
                },
            },
            mounted() {

                EventBus.$on("search-tag", tagName => {
                    this.$refs.bookmarkList.getBookmarkList({searchTag: tagName});
                });

                EventBus.$on("search-term", searchTerm => {
                    this.$refs.bookmarkList.getBookmarkList({searchTerm: searchTerm});
                });

                EventBus.$on("get-page", pageNumber => {
                    this.$refs.bookmarkList.getBookmarkList({pageNumber: pageNumber});
                });

                EventBus.$on("randomize", () => {
                    this.$refs.bookmarkList.getBookmarkList({randomize: true});
                });

            }
        });

        const AddNote = {
            data() {
                return {
                    note: ""
                }
            },
            methods: {
                onClick(evt) {

                    const note = document.getElementById("note").value;
                    var selectedId = document.querySelector("tr.bookmark-list.selected").dataset.id;

                    const bodyFormData = new URLSearchParams();
                    bodyFormData.append("tag", this.$store.getters.selectedTagName);
                    bodyFormData.append("link_id", selectedId);
                    bodyFormData.append("note", note);

                    axios("{% url 'bookmark_add_note' %}", {
                        method: "POST",
                        data: bodyFormData
                    }).then(() => {

                        payload = {
                            id: selectedId,
                            noteValue: note
                        }
                        EventBus.$emit("foobar", payload);

                    }, (error) => {
                        this.$bvToast.toast(String(error), {
                            title: "Error",
                            noAutoHide: true,
                            variant: "danger"
                        })
                        console.log(error);
                    })
                }
            },
            mounted() {

                EventBus.$on("setNoteValue", payload => {
                    this.note = payload;
                });

            }
        }

        const TagList = {
            data() {
                return {
                    favoriteTags: [
                        {
                            id: -1,
                            name: "Favorite Tags",
                            isHeader: true,
                            isActive: false,
                            isDraggable: false,
                        },
                        {
                            id: -2,
                            name: "Untagged",
                            isActive: true,
                            isDraggable: false,
                            count: {{ tag_counts|dict_get:"Untagged" }},
                        },
                        {% for tag in favorite_tags %}
                        {
                            id: {{ tag.id }},
                            name: "{{ tag.name }}",
                            isActive: false,
                            isDraggable: true,
                            count: {{ tag_counts|dict_get:tag.name }},
                        },
                        {% endfor %}
                    ],
                    selectedTag: null
                }
            },
            methods: {
                onClick(evt) {
                    const tagName = evt.srcElement.dataset.tag;
                    this.selectedTag = tagName;

                    for (tag of this.favoriteTags) {
                        if (tag.name == tagName) {
                            tag.isActive = true;
                        } else {
                            tag.isActive = false;
                        }
                    }

                    if (tagName == "Untagged") {
                        this.$store.commit("selectedTagName", "");
                        isFiltered = false;
                        EventBus.$emit("get-page", 1);
                        this.$store.commit("addFavoriteButtonVisible", false)
                        this.$store.commit("removeFavoriteButtonVisible", false)
                    } else {
                        EventBus.$emit("search-tag", tagName);
                        this.$store.commit("addFavoriteButtonVisible", false)
                        this.$store.commit("removeFavoriteButtonVisible", true)
                    }
                },
                getClassName(tagName) {

                    if (tagName == this.selectedTag) {
                        return "badge-light";
                    } else {
                        return "badge-primary";
                    }
                },
                onChange(evt) {

                    tagId = evt.moved.element.id;

                    // The backend expects the ordering to begin
                    // with 1, not 0, so add 1.
                    newPosition = evt.moved.newIndex - 1;

                    const bodyFormData = new URLSearchParams();
                    bodyFormData.append("tag_id", tagId);
                    bodyFormData.append("new_position", newPosition);

                    axios("{% url "sort_favorite_tags" %}", {
                        method: "POST",
                        data: bodyFormData,
                    }).then(response => {
                        if (response.data.status != "OK") {
                            this.$bvToast.toast(response.data.message, {
                                title: "Error",
                                noAutoHide: true,
                                variant: "danger"
                            })
                            console.log("Error: ", response.data.message);
                        } else {
                            console.log("Success: ", response.data);
                        }
                    })
                      .catch((error) => {
                          this.$bvToast.toast(error, {
                              title: "Error",
                              noAutoHide: true,
                              variant: "danger"
                          })
                          console.error("Error:", error);
                      });
                }
            },
            mounted() {

                EventBus.$on("search-tag", tagName => {

                    if (!this.favoriteTags.find(element => element.name == tagName)) {
                        this.$store.commit("addFavoriteButtonVisible", true)
                        this.$store.commit("removeFavoriteButtonVisible", false)
                    } else {
                        this.$store.commit("addFavoriteButtonVisible", false)
                        this.$store.commit("removeFavoriteButtonVisible", true)
                    }

                });

                EventBus.$on("select-favorite-tag", tagName => {

                    for (tag of this.favoriteTags) {
                        if (tag.name == tagName) {
                            tag.isActive = true;
                        } else {
                            tag.isActive = false;
                        }
                    }

                });

            }
        };

        const RandomizeButton = {
            methods: {
                onClick(evt) {
                    EventBus.$emit("select-favorite-tag", null);
                    this.$store.commit("addFavoriteButtonVisible", false)
                    this.$store.commit("removeFavoriteButtonVisible", false)
                    EventBus.$emit("randomize");
                }
            }
        }

        new Vue({
            el: "#vue-app-left",
            store,
            components: {
                AddNote,
                TagList,
                RandomizeButton
            }
        });

    </script>

{% endblock %}
